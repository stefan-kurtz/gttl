/* DO NOT EDIT. GENERATED BY enum_with_string.py --prefix Score_matrix_
 * ScoreMatrixName undefined blosum62 unit_score_aa unit_score_nuc
 * unit_score_nuc_2_2 unit_score_nuc_lower unit_score_nuc_upper */
#ifndef SCORE_MATRIX_NAME_HPP
#define SCORE_MATRIX_NAME_HPP

#include <cstddef>
#include <stdexcept>
#include <string>
#include <vector>
#include <cassert>

enum EnumScoreMatrixName
{
  Score_matrix_undefined,
  Score_matrix_blosum62,
  Score_matrix_unit_score_aa,
  Score_matrix_unit_score_nuc,
  Score_matrix_unit_score_nuc_2_2,
  Score_matrix_unit_score_nuc_lower,
  Score_matrix_unit_score_nuc_upper
};

class ScoreMatrixName
{
  static constexpr const char *string_values[] = {
      "undefined",           "blosum62",           "unit_score_aa",
      "unit_score_nuc",      "unit_score_nuc_2_2", "unit_score_nuc_lower",
      "unit_score_nuc_upper"};
  static constexpr const size_t num_values =
      sizeof string_values / sizeof string_values[0];
  EnumScoreMatrixName value;

 public:
  ScoreMatrixName(void) : value(Score_matrix_undefined) {}
  std::string string_values_joined(const char *sep,
                                   size_t start_index = 1) const noexcept
  {
    assert(start_index < num_values);
    std::string out_string{string_values[start_index]};
    for (size_t idx = start_index + 1; idx < num_values; idx++)
    {
      out_string += std::string(sep) + std::string(string_values[idx]);
    }
    return out_string;
  }
  void set(const std::string &str, size_t start_index = 1)
  {
    size_t idx;
    for (idx = 0; idx < num_values; idx++)
    {
      if (str == std::string(string_values[idx]))
      {
        value = static_cast<EnumScoreMatrixName>(idx);
        break;
      }
    }
    if (idx == num_values)
    {
      throw std::runtime_error(
        std::string("illegal argument ") + str +
        std::string(", possible values are: ") +
        string_values_joined(", ", start_index));
    }
  }
  bool is(EnumScoreMatrixName param) const noexcept { return value == param; }
  std::string str(void) const noexcept
  {
    assert(static_cast<size_t>(value) < num_values);
    return string_values[static_cast<size_t>(value)];
  }
  std::vector<std::string> string_values_get(void) const noexcept
  {
    std::vector<std::string> vec_s{};
    vec_s.reserve(num_values);
    for (size_t idx = 0; idx < num_values; idx++)
    {
      vec_s.push_back(string_values[idx]);
    }
    return vec_s;
  }
};
#endif
