/* generated by ./ssw_gen.py 8 DO NOT EDIT */
#ifndef SW_SIMD_UINT8_HPP
#define SW_SIMD_UINT8_HPP
template <bool forward_reading, bool forward_strand>
static SWsimdResult sw_simd_uint8(GTTL_UNUSED const uint8_t *original_dbseq,
                                  GTTL_UNUSED size_t original_dbseq_len,
                                  size_t dbseq_len, size_t query_len,
                                  const uint8_t weight_gapO,
                                  const uint8_t weight_gapE,
                                  const simd_int *vProfile,
                                  /* best alignment score: used to terminate
                                     the matrix calculation when locating the
                                     alignment beginning point. If this score
                                     is set to 0, it will not be used */
                                  uint8_t expected_score,
                                  uint8_t abs_smallest_score,
                                  SSWresources *ssw_resources)
{
  SWsimdResult sw_simd_result(0, query_len - 1, UINT8_MAX);
  const size_t simd_size = SIMD_VECSIZE_INT * 4,
               segment_len = (query_len + simd_size - 1) / simd_size;
  uint8_t max_align_score = 0;
  int step;
  bool own_resources;
  const simd_int vZero = simdi32_set(0), vGapO = simdi8_set(weight_gapO),
                 vGapE = simdi8_set(weight_gapE);
  const simd_int vBias = simdi8_set(abs_smallest_score);
  print_simd_int<uint8_t>("vGapO: ", vGapO);
  simd_int vTemp;
  uint32_t cmp;

  if (ssw_resources == NULL)
  {
    ssw_resources = new SSWresources(8, query_len);
    own_resources = true;
  } else
  {
    assert(query_len <= ssw_resources->maximum_seq_len_get());
    ssw_resources->reset8(segment_len);
    own_resources = false;
  }
  simd_int *pvHStore = ssw_resources->vectors8_get();
  simd_int *pvHLoad = pvHStore + segment_len;
  simd_int *pvE = pvHLoad + segment_len;
  simd_int *pvHmax = pvE + segment_len;

  int64_t dbseq_pos, dbseq_pos_end;
  assert(dbseq_len > 0);
  if constexpr (forward_reading)
  {
    dbseq_pos = 0;
    dbseq_pos_end = static_cast<int64_t>(dbseq_len);
    step = 1;
  } else
  {
    dbseq_pos = static_cast<int64_t>(dbseq_len - 1);
    dbseq_pos_end = -1;
    step = -1;
  }

  /* outer loop to process the database sequence */
  while (dbseq_pos != dbseq_pos_end)
  {
    assert(dbseq_pos >= 0);
    uint8_t current_char;
    if constexpr (forward_strand)
    {
      current_char = original_dbseq[dbseq_pos];
    } else
    {
      if constexpr (forward_reading)
      {
        assert(dbseq_len == original_dbseq_len);
      }
      current_char = original_dbseq[original_dbseq_len - 1 - dbseq_pos];
      current_char = complement_uint8_wc_remains(current_char);
    }
    // printf("Current_char %d\n", current_char);
    size_t segment_pos;
    simd_int e, *pv, vF = vZero, vMaxColumn = vZero,
                     vH = pvHStore[segment_len - 1];
    const simd_int *vP =
        vProfile + segment_len * static_cast<size_t>(current_char);

    print_simd_int<uint8_t>("Initial vH: ", vH);
    vH = simdi8_shiftl1(vH); /* Shift the value in vH left by 2 byte. */

    print_simd_int<uint8_t>("vH shifted: ", vH);

    /* Swap the 2 H buffers. */
    pv = pvHLoad;
    pvHLoad = pvHStore;
    pvHStore = pv;

    /* inner loop to process the query sequence */
    for (segment_pos = 0; GTTL_IS_LIKELY(segment_pos < segment_len);
         ++segment_pos)
    {
      vH = simdui8_adds(vH, simdi_load(vP + segment_pos));
      vH = simdui8_subs(vH, vBias); /* vH will be always > 0 */
      print_simd_int<uint8_t>("for loop 1 vH: ", vH);

      /* Get max from vH, vE and vF. */
      e = simdi_load(pvE + segment_pos);
      vH = simdui8_max(vH, e);
      vH = simdui8_max(vH, vF);
      vMaxColumn = simdui8_max(vMaxColumn, vH);

      print_simd_int<uint8_t>("for loop 2 vH: ", vH);
      print_simd_int<uint8_t>("for loop 2 vMaxColumn: ", vMaxColumn);

      /* Save vH values. */
      simdi_store(pvHStore + segment_pos, vH);

      /* Update vE value. */
      vH = simdui8_subs(vH, vGapO); /* saturation arithmetic, result >= 0 */
      e = simdui8_subs(e, vGapE);
      e = simdui8_max(e, vH);
      simdi_store(pvE + segment_pos, e);

      /* Update vF value. */
      vF = simdui8_subs(vF, vGapE);
      vF = simdui8_max(vF, vH);

      /* Load the next vH. */
      vH = simdi_load(pvHLoad + segment_pos);
    }

    /* Lazy_F loop: has been revised to disallow adjacent insertion and
       then deletion, so do not update E(i, segment_pos), learn from SWPS3 */
#if 8 == 8

    /* reset pointers to the start of the saved data */
    vH = simdi_load(pvHStore);

    /* the computed vF value is for the given column.  since */
    /* we are at the end, we need to shift the vF value over */
    /* to the next column. */
    vF = simdi8_shiftl1(vF);
    vTemp = simdui8_subs(vH, vGapO);
    vTemp = simdui8_subs(vF, vTemp);
    vTemp = simdi8_eq(vTemp, vZero);

#ifndef AVX2
#define SSW_MAX_CMP_VALUE UINT16_MAX
#else
#define SSW_MAX_CMP_VALUE UINT32_MAX
#endif /* AVX2 */
    for (cmp = simdi8_movemask(vTemp), segment_pos = 0;
         cmp != SSW_MAX_CMP_VALUE; cmp = simdi8_movemask(vTemp))
    {
      vH = simdui8_max(vH, vF);
      vMaxColumn = simdui8_max(vMaxColumn, vH);
      simdi_store(pvHStore + segment_pos, vH);
      vF = simdui8_subs(vF, vGapE);
      segment_pos++;
      if (segment_pos >= segment_len)
      {
        segment_pos = 0;
        vF = simdi8_shiftl1(vF);
      }
      vH = simdi_load(pvHStore + segment_pos);
      vTemp = simdui8_subs(vH, vGapO);
      vTemp = simdui8_subs(vF, vTemp);
      vTemp = simdi8_eq(vTemp, vZero);
    }
#else
    for (size_t k = 0; GTTL_IS_LIKELY(k < simd_size); ++k)
    {
      vF = simdi8_shiftl1(vF);
      for (segment_pos = 0; GTTL_IS_LIKELY(segment_pos < segment_len);
           ++segment_pos)
      {
        vH = simdi_load(pvHStore + segment_pos);
        vH = simdi8_max(vH, vF);
        vMaxColumn = simdi8_max(vMaxColumn, vH); /*newly added line */
        simdi_store(pvHStore + segment_pos, vH);
        /* Update vF value. */
        vH = simdui8_subs(vH, vGapO);
        vF = simdui8_subs(vF, vGapE);
        if (GTTL_IS_UNLIKELY(!simdi8_movemask(simdi8_gt(vF, vH))))
        {
          break;
        }
      }
      if (segment_pos < segment_len)
      {
        break;
      }
    }
#endif

    simd_int vMaxScore = vZero; /* highest score of the whole matrix. */
    print_simd_int<uint8_t>("vMaxScore: ", vMaxScore);
    print_simd_int<uint8_t>("vMaxColumn: ", vMaxColumn);
    vMaxScore = simdui8_max(vMaxScore, vMaxColumn);
    print_simd_int<uint8_t>("vMaxScore: ", vMaxScore);
    simd_int vMaxMark = vZero; /* highest score until previous column. */
    vTemp = simdi8_eq(vMaxMark, vMaxScore);
    cmp = simdi8_movemask(vTemp);
    if (cmp != SSW_MAX_CMP_VALUE)
    {
      const uint8_t local_max_score = simdi8_hmax(vMaxScore);

      vMaxMark = vMaxScore;
      if (GTTL_IS_LIKELY(local_max_score > max_align_score))
      {
        max_align_score = local_max_score;
        if (static_cast<uint32_t>(max_align_score) +
                static_cast<uint32_t>(abs_smallest_score) >=
            UINT8_MAX)
        {
          break; /*overflow */
        }
        sw_simd_result.on_dbseq = static_cast<size_t>(dbseq_pos);
        /* Store the column with the highest alignment score in order to
           trace the alignment ending position on query. */
        memcpy(pvHmax, pvHStore, segment_len * sizeof *pvHmax);
      }
    }

    /* Record the max score of current column. */
    if (expected_score > 0 && simdi8_hmax(vMaxColumn) == expected_score)
    {
      break;
    }
    dbseq_pos += step;
  }

  if (static_cast<uint32_t>(max_align_score) +
          static_cast<uint32_t>(abs_smallest_score) <
      UINT8_MAX)
  {
    /* Trace the column with the max alignment score for the ending
       position on query. */
    uint8_t *ptr = reinterpret_cast<uint8_t *>(pvHmax);
    const size_t column_len = segment_len * simd_size;
    for (size_t i = 0; GTTL_IS_LIKELY(i < column_len); ++i, ++ptr)
    {
      if (*ptr == max_align_score)
      {
        const size_t current_end =
            i / simd_size + (i % simd_size) * segment_len;
        if (current_end < sw_simd_result.on_query)
        {
          sw_simd_result.on_query = current_end;
        }
      }
    }
    sw_simd_result.opt_loc_alignment_score = max_align_score;
  }
  if (own_resources)
  {
    delete ssw_resources;
  }
  return sw_simd_result;
}
#endif
