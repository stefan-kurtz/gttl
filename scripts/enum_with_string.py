#!/usr/bin/env python3

import sys, argparse

def template_code(classname,items):
  return f'''#ifndef {classname.upper()}_HPP
#define {classname.upper()}_HPP

#include <cstddef>
#include <string>
#include <vector>
#include <cassert>

enum Enum{classname}
{{
  {', '.join(items)}
}};

class {classname}
{{
  static constexpr const char *string_values[]
    = {{{', '.join(['"{}"'.format(s.lower()) for s in items])}}};
  static constexpr const size_t num_values
    = sizeof string_values/sizeof string_values[0];
  Enum{classname} value;
  public:
  {classname}(void) : value({items[0]}) {{}}
  std::string string_values_joined(const char *sep) const noexcept
  {{
    static_assert(num_values > 0);
    std::string out_string{{string_values[0]}};
    for (size_t idx = 1; idx < num_values; idx++)
    {{
      out_string += std::string(sep) + std::string(string_values[idx]);
    }}
    return out_string;
  }}
  void set(const std::string &str)
  {{
    size_t idx;
    for (idx = 0; idx < num_values; idx++)
    {{
      if (str == std::string(string_values[idx]))
      {{
        value = static_cast<Enum{classname}>(idx);
        break;
      }}
    }}
    if (idx == num_values)
    {{
      throw(std::string("illegal argument ") + str +
            std::string(", possible values are: ") +
            string_values_joined(", "));
    }}
  }}
  bool is(Enum{classname} param) const noexcept
  {{
    return value == param;
  }}
  std::string str(void) const noexcept
  {{
    assert(static_cast<size_t>(value) < num_values);
    return string_values[(int) value];
  }}
  std::vector<std::string> string_values_get(void) const noexcept
  {{
    std::vector<std::string> vec_s{{}};
    for (size_t idx = 0; idx < num_values; idx++)
    {{
      vec_s.push_back(string_values[idx]);
    }}
    return vec_s;
  }}
}};
#endif'''

def parse_arguments(argv):
  p = argparse.ArgumentParser(description=('generate code for enumeration '
                                           'class with string representations'))
  p.add_argument('classname',type=str,
                  help='specify name of class')
  p.add_argument('items',nargs='+',
                  help='specify items of enumeration')
  return p.parse_args(argv)

args = parse_arguments(sys.argv[1:])

print('/* DO NOT EDIT. GENERATED BY {} */'.format(' '.join(sys.argv)))
print(template_code(args.classname,args.items))
