#!/usr/bin/env python3

import sys, argparse, os

def template_code(filetag,classname,prefix,items):
  return f'''#ifndef {filetag}_HPP
#define {filetag}_HPP

#include <cstddef>
#include <string>
#include <vector>
#include <cassert>

enum Enum{classname}
{{
  {', '.join(['{}{}'.format(prefix,item) for item in items])}
}};

class {classname}
{{
  static constexpr const char *string_values[]
    = {{{', '.join(['"{}"'.format(s.lower()) for s in items])}}};
  static constexpr const size_t num_values
    = sizeof string_values/sizeof string_values[0];
  Enum{classname} value;
  public:
  {classname}(void) : value({'{}{}'.format(prefix,items[0])}) {{}}
  std::string string_values_joined(const char *sep, size_t start_index = 1)
    const noexcept
  {{
    assert(start_index < num_values);
    std::string out_string{{string_values[start_index]}};
    for (size_t idx = start_index + 1; idx < num_values; idx++)
    {{
      out_string += std::string(sep) + std::string(string_values[idx]);
    }}
    return out_string;
  }}
  void set(const std::string &str, size_t start_index=1)
  {{
    size_t idx;
    for (idx = 0; idx < num_values; idx++)
    {{
      if (str == std::string(string_values[idx]))
      {{
        value = static_cast<Enum{classname}>(idx);
        break;
      }}
    }}
    if (idx == num_values)
    {{
      throw std::runtime_error(
        std::string("illegal argument ") + str +
        std::string(", possible values are: ") +
        string_values_joined(", ", start_index));
    }}
  }}
  bool is(Enum{classname} param) const noexcept
  {{
    return value == param;
  }}
  std::string str(void) const noexcept
  {{
    assert(static_cast<size_t>(value) < num_values);
    return string_values[static_cast<size_t>(value)];
  }}
  std::vector<std::string> string_values_get(void) const noexcept
  {{
    std::vector<std::string> vec_s{{}};
    for (size_t idx = 0; idx < num_values; idx++)
    {{
      vec_s.push_back(string_values[idx]);
    }}
    return vec_s;
  }}
}};
#endif'''

def parse_arguments(argv):
  p = argparse.ArgumentParser(description=('generate code for enumeration '
                                           'class with string representations'))
  p.add_argument('-p','--prefix',type=str,default='',
                 help='specify prefix of identifiers')
  p.add_argument('classname',type=str,
                  help='specify name of class')
  p.add_argument('items',nargs='+',
                  help='specify items of enumeration')
  return p.parse_args(argv)

def classname2file_tag(classname):
  char_list = list()
  for idx, a in enumerate(classname):
    if ord(a) >= ord('A') and ord(a) <= ord('Z'):
      if idx > 0:
        char_list.append('_{}'.format(a))
      else:
        char_list.append(a)
    else:
      char_list.append(a.upper())
  return ''.join(char_list)

args = parse_arguments(sys.argv[1:])
file_tag = classname2file_tag(args.classname)

print('/* DO NOT EDIT. GENERATED BY {} {} */'
       .format(os.path.basename(sys.argv[0]),' '.join(sys.argv[1:])))
print(template_code(file_tag,args.classname,args.prefix,args.items))
